// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package opentelemetry.proto.metrics.v1;

import "opentelemetry/proto/common/v1/common.proto";
import "opentelemetry/proto/resource/v1/resource.proto";

option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.metrics.v1";
option java_outer_classname = "MetricsProto";
option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/metrics/v1";

message ResourceMetrics {
  opentelemetry.proto.resource.v1.Resource resource = 1;

  repeated InstrumentationLibraryMetrics instrumentation_library_metrics = 2;
}

message InstrumentationLibraryMetrics {
  opentelemetry.proto.common.v1.InstrumentationLibrary instrumentation_library = 1;

  repeated Metric metrics = 2;
}

message Metric {
  MetricDescriptor metric_descriptor = 1;

  repeated DataValue values = 2;
}

message MetricDescriptor {
  string name = 1;
  string description = 2;
  string unit = 3;

  enum ValueType {
    INVALID_VALUE_TYPE = 0;
    INTEGER = 1;
    FLOAT = 2;
    HISTOGRAM = 4;
    SUMMARY = 5;  // MMLSC + Non-mergeable quantiles

    // Sketches, extensions, ...
  }

  ValueType type = 4;

  enum Kind {
    INVALID_KIND = 0;

    // One of the following three MUST be set. There are 3 exclusive Temporality kinds.
    // MASK_INSTANTANEOUS = 1 << 0
    // MASK_CUMULATIVE    = 1 << 1
    // MASK_DELTA         = 1 << 2
    //
    // One of the following two MUST be set. There are 2 exclusive Structure kinds.
    // MASK_GROUPING = 1 << 3
    // MASK_ADDING   = 1 << 4
    //
    // May be set with MASK_ADDING.
    // MASK_MONOTONIC = 1 << 5
    //
    // May be set for any instrument.
    // MASK_SYNCHRONOUS = 1 << 6
    //
    // The following codes are generated
    
    ADDING_MONOTONIC_INSTANTANEOUS_SYNCHRONOUS  = 0x71; // MASK_ADDING|MASK_INSTANTANEOUS|MASK_MONOTONIC|MASK_SYNCHRONOUS
    ADDING_MONOTONIC_INSTANTANEOUS_ASYNCHRONOUS = 0x31; // MASK_ADDING|MASK_INSTANTANEOUS|MASK_MONOTONIC
    ADDING_MONOTONIC_CUMULATIVE_SYNCHRONOUS     = 0x72; // MASK_ADDING|MASK_CUMULATIVE|MASK_MONOTONIC|MASK_SYNCHRONOUS
    ADDING_MONOTONIC_CUMULATIVE_ASYNCHRONOUS    = 0x32; // MASK_ADDING|MASK_CUMULATIVE|MASK_MONOTONIC
    ADDING_MONOTONIC_DELTA_SYNCHRONOUS          = 0x74; // MASK_ADDING|MASK_DELTA|MASK_MONOTONIC|MASK_SYNCHRONOUS
    ADDING_MONOTONIC_DELTA_ASYNCHRONOUS         = 0x34; // MASK_ADDING|MASK_DELTA|MASK_MONOTONIC

    ADDING_INSTANTANEOUS_SYNCHRONOUS            = 0x51; // MASK_ADDING|MASK_INSTANTANEOUS|MASK_SYNCHRONOUS
    ADDING_INSTANTANEOUS_ASYNCHRONOUS           = 0x11; // MASK_ADDING|MASK_INSTANTANEOUS
    ADDING_CUMULATIVE_SYNCHRONOUS               = 0x52; // MASK_ADDING|MASK_CUMULATIVE|MASK_SYNCHRONOUS
    ADDING_CUMULATIVE_ASYNCHRONOUS              = 0x12; // MASK_ADDING|MASK_CUMULATIVE
    ADDING_DELTA_SYNCHRONOUS                    = 0x54; // MASK_ADDING|MASK_DELTA|MASK_SYNCHRONOUS
    ADDING_DELTA_ASYNCHRONOUS                   = 0x14; // MASK_ADDING|MASK_DELTA

    GROUPING_INSTANTANEOUS_SYNCHRONOUS          = 0x49; // MASK_GROUPING|MASK_INSTANTANEOUS|MASK_SYNCHRONOUS
    GROUPING_INSTANTANEOUS_ASYNCHRONOUS         = 0x9;  // MASK_GROUPING|MASK_INSTANTANEOUS
    GROUPING_CUMULATIVE_SYNCHRONOUS             = 0x4a; // MASK_GROUPING|MASK_CUMULATIVE|MASK_SYNCHRONOUS
    GROUPING_CUMULATIVE_ASYNCHRONOUS            = 0xa;  // MASK_GROUPING|MASK_CUMULATIVE
    GROUPING_DELTA_SYNCHRONOUS                  = 0x4c; // MASK_GROUPING|MASK_DELTA|MASK_SYNCHRONOUS
    GROUPING_DELTA_ASYNCHRONOUS                 = 0xc;  // MASK_GROUPING|MASK_DELTA
  }

  Kind kind = 5;
}

message DataValue {
  // (Same comment)
  repeated opentelemetry.proto.common.v1.StringKeyValue labels = 1;

  // (Same comment)
  // If omitted and not instantaneous, this is taken as the default _REPORT_TIMESTAMP_.
  fixed64 start_time_unix_nano = 2;

  // (Same comment)
  // Use this in conjunction with `value_int64` and `value_double`, or `summary`.
  // When the value type is instantaneous, it applies to *this point* 
  fixed64 time_unix_nano = 3;

  // A logical oneof among the following fields, as prescribed by ValueType:

  // INT64
  // ADDING -> Sum, Grouping -> RAW
  int64 value_int64 = 4;

  // FLOAT
  // (as above)
  double value_double = 6;

  // HISTOGRAM
  // (Similar comments)
  // Note this is an exact representation for Adding instruments.
  Histogram histogram = 8;

  // SUMMARY
  // (see changes below)
  Summary summary = 9;

  // Optional exemplars
  // Import connor's code
  // Exemplar exemplars = 10;
}

message Histogram {
  // Same except without labels, start_time, or time fields.
}

// TODO RAW?
  // Raw values w/ inspecific timestamp
  // repeated int64 multi_int64 = 11 [packed=true];
  // repeated int64 multi_double = 12 [packed=true];

// SummaryDataPoint is a single data point in a timeseries that describes the time-varying
// values of a Summary metric.
message Summary {
  // Remove the labels, start_time, and time fields.
  //
  // TODO: Add min, max, last fields
  // as described in https://github.com/open-telemetry/oteps/pull/117
  //
  // TODO: Why does Histogram not go here?

  // (Same comment)
  uint64 count = 1;  // Also TODO: count fields uint64->double because of sampling

  // (Same comment)
  int64  sum_int64 = 2;
  double sum_double = 3;

  // MIN, MAX, LAST value
  int64  min_int64 = 4;
  double min_double = 5;

  int64  max_int64 = 6;
  double max_double = 7;

  int64  last_int64 = 8;
  double last_double = 9;
  
  // (Similar comments)
  message ValueAtQuantile {
    double quantile = 1;  // [0,1], if 0 prefer MIN, if 1 prefer MAX.
    int64  value_int64 = 2;
    double value_double = 3;
  }

  // (Same comment)
  repeated ValueAtQuantile quantile_values = 10;
}
