// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package opentelemetry.proto.metrics.v1;

import "opentelemetry/proto/common/v1/common.proto";
import "opentelemetry/proto/resource/v1/resource.proto";

option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.metrics.v1";
option java_outer_classname = "MetricsProto";
option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/metrics/v1";

message ResourceMetrics {
  opentelemetry.proto.resource.v1.Resource resource = 1;

  repeated InstrumentationLibraryMetrics instrumentation_library_metrics = 2;
}

message InstrumentationLibraryMetrics {
  opentelemetry.proto.common.v1.InstrumentationLibrary instrumentation_library = 1;

  repeated Metric metrics = 2;
}

message Metric {
  MetricDescriptor metric_descriptor = 1;

  repeated DataPoint points = 2;
}

message MetricDescriptor {
  string name = 1;
  string description = 2;
  string unit = 3;

  enum ValueType {
    INVALID_VALUE_TYPE = 0;
    INT64 = 1;    // A scalar: SUM or LASTVALUE
    DOUBLE = 2;      // A scalar: SUM or LASTVALUE
    HISTOGRAM = 4;  // ...
    SUMMARY = 5;    // MMLSC + Non-mergeable quantiles
    RAW = 6;        // The exemplars are the value

    // Sketches and other type extensions.
  }

  ValueType value_type = 4;

  enum KindMask {
    INVALID_KIND_MASK = 0;

    // One of the following three MUST be set. There are 3 exclusive Temporality kinds.
    INSTANTANEOUS = 0x1;
    CUMULATIVE    = 0x2;
    DELTA         = 0x4;

    // One of the following two MUST be set. There are 2 exclusive Structure kinds.
    GROUPING      = 0x8;
    ADDING        = 0x10;

    // May be set with ADDING.
    MONOTONIC     = 0x20;

    // May be set for any instrument.
    SYNCHRONOUS   = 0x40;
  }

  enum Kind {
    INVALID_KIND = 0;

    // The following codes are generated from the valid combinations of the mask bits above.
    
    ADDING_MONOTONIC_INSTANTANEOUS_SYNCHRONOUS  = 0x71;
    ADDING_MONOTONIC_INSTANTANEOUS_ASYNCHRONOUS = 0x31;
    ADDING_MONOTONIC_CUMULATIVE_SYNCHRONOUS     = 0x72;
    ADDING_MONOTONIC_CUMULATIVE_ASYNCHRONOUS    = 0x32;
    ADDING_MONOTONIC_DELTA_SYNCHRONOUS          = 0x74;
    ADDING_MONOTONIC_DELTA_ASYNCHRONOUS         = 0x34;

    ADDING_INSTANTANEOUS_SYNCHRONOUS            = 0x51;
    ADDING_INSTANTANEOUS_ASYNCHRONOUS           = 0x11;
    ADDING_CUMULATIVE_SYNCHRONOUS               = 0x52;
    ADDING_CUMULATIVE_ASYNCHRONOUS              = 0x12;
    ADDING_DELTA_SYNCHRONOUS                    = 0x54;
    ADDING_DELTA_ASYNCHRONOUS                   = 0x14;

    GROUPING_INSTANTANEOUS_SYNCHRONOUS          = 0x49;
    GROUPING_INSTANTANEOUS_ASYNCHRONOUS         = 0x9; 
    GROUPING_CUMULATIVE_SYNCHRONOUS             = 0x4a;
    GROUPING_CUMULATIVE_ASYNCHRONOUS            = 0xa; 
    GROUPING_DELTA_SYNCHRONOUS                  = 0x4c;
    GROUPING_DELTA_ASYNCHRONOUS                 = 0xc; 
  }

  Kind kind = 5;
}

message DataPoint {
  // (Same comment)
  repeated opentelemetry.proto.common.v1.StringKeyValue labels = 1;

  // (Same comment)
  // If omitted and not instantaneous, this is taken as the default _REPORT_TIMESTAMP_.
  fixed64 start_time_unix_nano = 2;

  // (Same comment)
  // Use this in conjunction with `value_int64` and `value_double`, or `summary`.
  // When the kind is instantaneous, this field applies to *this point*.  
  fixed64 time_unix_nano = 3;

  // A logical oneof among the following fields, as prescribed by ValueType:

  // INT64/FLOAT ADDING -> Sum (Counter), Grouping -> RAW (Gauge); This
  // could be "last value" or it could be a random value (or other
  // selection approach)
  int64 value_int64 = 4;
  double value_double = 5;

  // HISTOGRAM
  // (Similar comments)
  // Note this is an exact representation for Adding instruments.
  Histogram histogram = 6;

  // SUMMARY
  // (see changes below)
  Summary summary = 7;

  // Optional exemplars
  repeated RawValue exemplars = 8;
}

// TODO: How to get MIN/MAX/LAST (which are not unique) via exemplars?
//  -> require the use of MMLSC?

// TODO RAW?
  // Raw values w/ inspecific timestamp
  // repeated int64 multi_int64 = 11 [packed=true];
  // repeated int64 multi_double = 12 [packed=true];


// MONDAY THINKING

// Guidelines:
// Use Summary+MMLSC to store a LastValue with corresponding Count/Sum.
// Use LASTVALUE to store a LastValue w/o count.
// Use SUM to store a Sum w/o count.
// Use RAW to store




// SummaryDataPoint is a single data point in a timeseries that describes the time-varying
// values of a Summary metric.
message Summary {
  // Remove the labels, start_time, and time TODO.
  //
  // fields: Add min, max, last fields
  // as described in https://github.com/open-telemetry/oteps/pull/117
  //
  // (Same comment)
  uint64 count = 1;

  // (Same comment)
  int64  sum_int64 = 2;
  double sum_double = 3;

  // MIN, MAX, LAST value
  int64  min_int64 = 4;
  double min_double = 5;

  int64  max_int64 = 6;
  double max_double = 7;

  int64  last_int64 = 8;
  double last_double = 9;
  
  // (Similar comments)
  message ValueAtQuantile {
    double quantile = 1;  // [0,1], if 0 prefer MIN, if 1 prefer MAX.
    int64  value_int64 = 2;
    double value_double = 3;
  }

  // (Same comment)
  repeated ValueAtQuantile quantile_values = 10;
}

message RawValue {
  // Numerical value of the measurement that was recorded. Only one of these 
  // two fields is used for the data, based on MetricDescriptor.measurement_type
  double value_double = 1;
  int64 value_int64 = 2;

  // Exact time that the measurement was recorded
  fixed64 time_unix_nano = 3;

  // Labels that were passed with the measurement, but not included in the DataPoint's labels
  repeated opentelemetry.proto.common.v1.StringKeyValue additional_labels = 4;

  // (Optional) Span ID of the current trace
  bytes span_id = 5;

  // (Optional) Trace ID of the current trace
  bytes trace_id = 6;

  // (Optional) When sample_count is non-zero, this exemplar has been chosen in a statistically
  // unbiased way such that the exemplar is representative of `sample_count` individual events
  double sample_count = 7;
}

message Histogram {
  // count is the number of values in the population. Must be non-negative. This value
  // must be equal to the sum of the "count" fields in buckets if a histogram is provided.
  uint64 count = 4;

  // sum of the values in the population. If count is zero then this field
  // must be zero. This value must be equal to the sum of the "sum" fields in buckets if
  // a histogram is provided.
  double sum = 5;

  // Bucket contains values for a bucket.
  message Bucket {
    // The number of values in each bucket of the histogram, as described by
    // bucket_options.
    uint64 count = 1;

    // Exemplars are example points that may be used to annotate aggregated
    // Histogram values. They are metadata that gives information about a
    // particular value added to a Histogram bucket.
    message Exemplar {
      // Value of the exemplar point. It determines which bucket the exemplar belongs to.
      // If bucket_options define bounds for this bucket then this value must be within
      // the defined bounds.
      double value = 1;

      // time_unix_nano is the moment when this exemplar was recorded.
      // Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
      fixed64 time_unix_nano = 2;

      // exemplar_attachments are contextual information about the example value.
      // Keys in this list must be unique.
      repeated opentelemetry.proto.common.v1.StringKeyValue attachments = 3;
    }

    // exemplar is an optional representative value of the bucket.
    Exemplar exemplar = 2;
  }

  // buckets is an optional field contains the values of histogram for each bucket.
  //
  // The sum of the values in the buckets "count" field must equal the value in the count field.
  //
  // The number of elements in buckets array must be by one greater than the
  // number of elements in bucket_bounds array.
  //
  // Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
  // must also be present and number of elements in this field must be equal to the
  // number of buckets defined by bucket_options.
  repeated Bucket buckets = 6;

  // A histogram may optionally contain the distribution of the values in the population.
  // In that case one of the option fields below and "buckets" field both must be defined.
  // Otherwise all option fields and "buckets" field must be omitted in which case the
  // distribution of values in the histogram is unknown and only the total count and sum are known.

  // explicit_bounds is the only supported bucket option currently.
  // TODO: Add more bucket options.

  // explicit_bounds specifies buckets with explicitly defined bounds for values.
  // The bucket boundaries are described by "bounds" field.
  //
  // This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  // at index i are:
  //
  // [0, bounds[i]) for i == 0
  // [bounds[i-1], bounds[i]) for 0 < i < N-1
  // [bounds[i], +infinity) for i == N-1
  // The values in bounds array must be strictly increasing and > 0.
  //
  // Note: only [a, b) intervals are currently supported for each bucket. If we decides
  // to also support (a, b] intervals we should add support for these by defining a boolean
  // value which decides what type of intervals to use.
  repeated double explicit_bounds = 7;
}
